// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command - DEPLOY INTAKE COMMAND

#include "commands/DeployIntakeCommand.h"
#include "iostream"

/**
 * code for deploy intake command
 * 
 * @author WAVE Robotics 2826
 */
DeployIntakeCommand::DeployIntakeCommand(Intake* intake) : m_intake(intake){
    // Use AddRequirements() here to declare subsystem dependencies
    // eg. AddRequirements(m_Subsystem);
    SetName("DeployIntakeCommand");
}

// Called just before this Command runs the first time
void DeployIntakeCommand::Initialize() 
{
    std::cout << "INTAKE DEPLOY COMMAND Initialize()" << std::endl;
    if (!m_intake->GetIntakeDeployed())
    {
        std::cout << "FRONT Initialize() >>> phase 1" << std::endl;
        phase = phase_1_beforeSensor;
    } 
    else 
    {
        std::cout << "FRONT Initialize() >>> phase 2" << std::endl;
        phase = phase_2_inSensor;
    }
}

// Called repeatedly when this Command is scheduled to run
void DeployIntakeCommand::Execute() 
{
    std::cout << "DEPLOY INTAKE COMMAND Execute()" << std::endl;
    switch(phase)
    {
        case phase_0_stowed:
            //right when the person press punch. 
            //If the sensor is currently seen go to insensor phase.
            //if sensor is not seen go to exit sensor phase.
            std::cout << "phase 0: stowed" << std::endl;
            if (!m_intake->GetIntakeDeployed())
            {
            phase = phase_1_beforeSensor;
            } 
            else 
            {
                phase = phase_2_inSensor;

            }
            break;
        case phase_1_beforeSensor:
            std::cout << "phase 1: before sensor" << std::endl;
            if(m_intake->GetIntakeDeployed())
            {
                //before sensor triggered, still need to keep rotating the cam.
                phase = phase_1_beforeSensor;
                m_intake->SetIntakeDeploy(0.5);
            }
            else
            {
                //in the sensor area, now we need to keep rotating until we are out of the sensor
                phase = phase_2_inSensor;
            }
            break;
        case phase_2_inSensor:
            //Do in sensor stuff
            std::cout << "phase 2: in sensor" << std::endl;
            if(m_intake->GetIntakeDeployed())
            {
                //still in sensor, keep the motor going
                phase = phase_2_inSensor;
                m_intake->SetIntakeDeploy(0.5);
            }
            else
            {
                //We left the sensor, now it's time to set triggered position
                // and go fixed distance further
                m_intake->SetTriggeredPosition(m_intake->GetIntakeDeployPosition());
                phase = phase_3_afterSensor;
            }
            break;
        case phase_3_afterSensor:
            // Do after sensor things
            // Now that we triggered the sensor and exited it, we need to know when 
            // we go the correct distance further to be fully deployed.
            std::cout << "phase 3: after sensor" << std::endl;
            phase = phase_3_afterSensor;
            if (fabs(m_intake->GetIntakeDeployPosition() - m_intake->GetTriggeredPosition()) < 2)
            {
                m_intake->SetIntakeDeploy(0.5);
                phase = phase_3_afterSensor;
            }
            else
            {
                phase = phase_4_fullyDeployed;
            }            
            break;
        default:
            phase = phase_0_stowed;
            break;
    }
}

// Make this return true when this Command no longer needs to run execute()
bool DeployIntakeCommand::IsFinished() 
{
    std::cout << "INTAKE DEPLOY COMMAND IsFinished()" << std::endl;
    if (phase == phase_4_fullyDeployed)
    {
        std::cout << "phase 4: fully deployed" << std::endl;
        return true;
    }
    else
    {
        return false;
    }    
}

// Called once after isFinished returns true
void DeployIntakeCommand::End(bool interrupted) {
    std::cout << "INTAKE DEPLOY COMMAND End()" << std::endl;
    m_intake->SetIntakeDeploy(0);
}

bool DeployIntakeCommand::RunsWhenDisabled() const {
    return false;
}
