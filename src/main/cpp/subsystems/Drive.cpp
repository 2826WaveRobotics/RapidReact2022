// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: PIDSubsystem - DRIVE

#include "subsystems/Drive.h"
#include "frc/smartdashboard/SmartDashboard.h"
#include <frc/controller/PIDController.h>
#include "frc/livewindow/LiveWindow.h"
#include "subsystems/Drive.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include "../include/Reference.h"

using namespace rev;
using namespace frc;

/**
 * code for drive train
 * 
 * @author WAVE Robotics 2826
 */
Drive::Drive() : frc2::PIDSubsystem(frc2::PIDController{kP, kI, kD}) {

    SetName("Drive");
    SetSubsystem("Drive");

    m_controller.SetTolerance(0.2);    
    m_rightFrontDrive = new CANSparkMax(RIGHT_FRONT_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightBackDrive = new CANSparkMax(RIGHT_BACK_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftFrontDrive = new CANSparkMax(LEFT_FRONT_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftBackDrive = new CANSparkMax(LEFT_BACK_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightControllerGroup = new MotorControllerGroup(*m_rightBackDrive, *m_rightFrontDrive);
    m_leftControllerGroup = new MotorControllerGroup(*m_leftBackDrive, *m_leftFrontDrive);
    m_waveDrive = new DifferentialDrive(*m_leftControllerGroup, *m_rightControllerGroup);

    // SAFETY SHOULD BE ENABLED
    m_waveDrive->SetSafetyEnabled(true);
    m_waveDrive->SetExpiration(0.2_s);
    m_waveDrive->SetMaxOutput(1.0);
    
    m_rightFrontDrive->SetInverted(false);
    m_rightBackDrive->SetInverted(false);

    m_leftFrontDrive->SetInverted(true);
    m_leftBackDrive->SetInverted(true);

    m_sparkMaxEncoder.SetDistancePerPulse(1.0);

    m_gyro = new AHRS(SPI::Port::kMXP);

    // Use these to get going:
    // SetSetpoint() -  Sets where the PID controller should move the system
    //                  to
    // Enable() - Enables the PID controller.
}


void Drive::Periodic() {
    // Put code here to be run every loop
    PIDSubsystem::Periodic();
}

void Drive::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
}

double Drive::GetMeasurement() {
    //return m_sparkMaxEncoder.GetDistance();
    return m_gyro->GetYaw();
}

void Drive::UseOutput(double output, double setpoint) {
    output += setpoint*kF;
    m_leftControllerGroup->Set(std::clamp(output, -1.0, 1.0));

}

void Drive::arcadeDrive(double move,double rotate)
{
    m_waveDrive->ArcadeDrive(move, -rotate);
}

// drive current getters
double Drive::GetRightFrontDriveCurrent()
{
    return m_rightFrontDrive->GetOutputCurrent();
}
double Drive::GetRightBackDriveCurrent()
{
    return m_rightBackDrive->GetOutputCurrent();
}
double Drive::GetLeftFrontDriveCurrent()
{
    return m_leftFrontDrive->GetOutputCurrent();
}
double Drive::GetLeftBackDriveCurrent()
{
    return m_leftBackDrive->GetOutputCurrent();
}