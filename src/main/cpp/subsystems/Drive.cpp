// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: PIDSubsystem - DRIVE

#include "subsystems/Drive.h"
#include "frc/smartdashboard/SmartDashboard.h"
#include <frc/controller/PIDController.h>
#include "frc/livewindow/LiveWindow.h"
#include "subsystems/Drive.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include "../include/Reference.h"
#include <iostream>

using namespace rev;
using namespace frc;

/**
 * code for drive train
 * 
 * @author WAVE Robotics 2826
 */
Drive::Drive() : frc2::PIDSubsystem(frc2::PIDController{kP, kI, kD}) {

    SetName("Drive");
    SetSubsystem("Drive");

    m_controller.SetTolerance(0.2);    
    m_rightFrontDrive = new CANSparkMax(RIGHT_FRONT_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightBackDrive = new CANSparkMax(RIGHT_BACK_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftFrontDrive = new CANSparkMax(LEFT_FRONT_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_leftBackDrive = new CANSparkMax(LEFT_BACK_DRIVE, CANSparkMaxLowLevel::MotorType::kBrushless);
    m_rightControllerGroup = new MotorControllerGroup(*m_rightBackDrive, *m_rightFrontDrive);
    m_leftControllerGroup = new MotorControllerGroup(*m_leftBackDrive, *m_leftFrontDrive);
    m_waveDrive = new DifferentialDrive(*m_leftControllerGroup, *m_rightControllerGroup);
    m_gyro = new AHRS(SPI::Port::kMXP);
    m_driveEncoder = new SparkMaxRelativeEncoder(m_leftBackDrive->GetEncoder());
    //m_turnPID =new PIDController();

    // drive motors set to coast
    m_rightFrontDrive->SetIdleMode(CANSparkMax::IdleMode::kCoast);
    m_leftFrontDrive->SetIdleMode(CANSparkMax::IdleMode::kCoast);
    m_rightBackDrive->SetIdleMode(CANSparkMax::IdleMode::kCoast);
    m_leftBackDrive->SetIdleMode(CANSparkMax::IdleMode::kCoast);

    // SAFETY SHOULD BE ENABLED
    m_waveDrive->SetSafetyEnabled(true);
    m_waveDrive->SetExpiration(0.2_s);
    m_waveDrive->SetMaxOutput(1.0);
    
    m_rightFrontDrive->SetInverted(false);
    m_rightBackDrive->SetInverted(false);

    m_leftFrontDrive->SetInverted(true);
    m_leftBackDrive->SetInverted(true);

    m_sparkMaxEncoder.SetDistancePerPulse(1.0);

    m_gyro = new AHRS(SPI::Port::kMXP);

    m_moveInputSpeed = 0;
    m_rotateInputSpeed = 0;

    m_previousMoveSpeed = 0;
    m_previousRotateSpeed = 0;

    // Use these to get going:
    // SetSetpoint() -  Sets where the PID controller should move the system
    //                  to
    // Enable() - Enables the PID controller.
}


double Drive::GetPreviousMoveSpeed() {
    return m_previousMoveSpeed;
}

void Drive::SetPreviousMoveSpeed(double speed) {
    m_previousMoveSpeed = speed;
}
double Drive::GetPreviousRotateSpeed() {
    return m_previousRotateSpeed;
}

void Drive::SetPreviousRotateSpeed(double speed) {
    m_previousRotateSpeed = speed;
}

void Drive::Periodic() {
    // Put code here to be run every loop
    PIDSubsystem::Periodic();
}

void Drive::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation
}

double Drive::GetMeasurement() {
    //return m_sparkMaxEncoder.GetDistance();
    return m_gyro->GetYaw();
}

void Drive::UseOutput(double output, double setpoint) {
    output += setpoint*kF;
    m_leftControllerGroup->Set(std::clamp(output, -1.0, 1.0));

}

void Drive::arcadeDrive(double move, double rotate)
{
    // std::cout << "ARCADE DRIVE: " << move << "," << rotate << std::endl;
    m_waveDrive->ArcadeDrive(move, -rotate);
}

// drive current getters
double Drive::GetRightFrontDriveCurrent()
{
    return m_rightFrontDrive->GetOutputCurrent();
}
double Drive::GetRightBackDriveCurrent()
{
    return m_rightBackDrive->GetOutputCurrent();
}
double Drive::GetLeftFrontDriveCurrent()
{
    return m_leftFrontDrive->GetOutputCurrent();
}
double Drive::GetLeftBackDriveCurrent()
{
    return m_leftBackDrive->GetOutputCurrent();
}

// double Drive::TransformDriveSpeed(double speed, double targetSpeed)
// {
//     double newSpeed = speed;

//     // less than target - ramp up
//     if (speed < targetSpeed)
//     {
//       // do not exceed 100% target speed
//       if ((speed + 0.1) > targetSpeed)
//       {
//         newSpeed = targetSpeed;
//       }
//       // increment speed to target
//       else
//       {
//         newSpeed = newSpeed + 0.1;
//       }
//     }
//     // more than target - ramp down
//     if (speed > targetSpeed)
//     {
//       // do not exceed -100% target speed
//       if ((speed - 0.1) < targetSpeed)
//       {
//         newSpeed = targetSpeed;
//       }
//       // decrement speed to target
//       else
//       {
//         newSpeed = newSpeed - 0.1;
//       }
//     }

//     return newSpeed;
// }

double Drive::LerpDriveSpeed(double speed, double targetSpeed, double movePercentage) {
    double newSpeed = speed;
    // current speed is less than target speed
    if (speed < targetSpeed)
    {
        newSpeed = speed + std::fabs(targetSpeed - speed) * movePercentage;
    }
    // current speed is greater than target speed
    else if (speed > targetSpeed)
    {
        newSpeed = speed - std::fabs(targetSpeed - speed) * movePercentage;
    }
    // adding a buffer between newSpeed and targetSpeed
    if (std::abs(targetSpeed - newSpeed) < 0.01f) {
        newSpeed = targetSpeed;
    }
    // prevent newSpeed from going outside of physical boundaries
    if (newSpeed <= -1.0f)
    {
        newSpeed = -1.0f;
    }
    else if (newSpeed >= 1.0f)
    {
        newSpeed = 1.0f;
    }

    return newSpeed;
}

// move input speed getters + setters
double Drive::GetMoveInputSpeed()
{
    return m_moveInputSpeed;
}
void Drive::SetMoveInputSpeed(double moveInputSpeed)
{
    m_moveInputSpeed = moveInputSpeed;
}

// rotate input speed getters + setters
double Drive::GetRotateInputSpeed()
{
    return m_rotateInputSpeed;
}
void Drive::SetRotateInputSpeed(double rotateInputSpeed)
{
    m_rotateInputSpeed = rotateInputSpeed;
}

float Drive::GetAngle(){
    return m_gyro->GetAngle();
}

void Drive::ZeroAngle(){
    m_gyro->ZeroYaw();
}

// drive position getters + setters
double Drive::GetDriveEncoderPosition()
{
    // std::cout << "ENTERED GET DRIVE POSITION" << std::endl;
    return m_driveEncoder->GetPosition() - m_drivePosition;
}
void Drive::ResetDrivePosition(double newPosition)
{
    // to 0 pass in GetDrivePosition
    m_drivePosition = newPosition;
}